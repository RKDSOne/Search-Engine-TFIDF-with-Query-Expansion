modulconvert convert a value from one unit of measurement to another example convert123lbkg 123 pounds 56 kg local minus unicode u2212 minus sign utf8 e2 88 92 local abs math abs local floor math floor local format string format local log10 math log10 local ustring mw ustring local ulen ustring len local usub ustring sub configuration options to keep magic values in one location conversion data and message text are defined in separate modules local config maxsigfig local numdot numsep each must be a single byte for simple regex searchreplace local defaultexceptions linkexceptions allunits local textcode local varname can be a code to use variable names that depend on value local fromentable to translate an output string of en digits to local language local toentable to translate an input string of digits in local language to en use translationtable in converttext to change the following local groupmethod 3 code for how many digits are in a group local perword for units like miles gallon local pluralsuffix only other useful value is probably to disable plural unit names all units should be defined in the data module however to cater for quick changes and experiments any unknown unit is looked up in an extra data module if it exists that module would be transcluded in only a small number of pages so there should be little server overhead from making changes and changes should propagate quickly local extramodule name of module with extra units local extraunits nil or table of extra units from extramodule local function booleantext return true if text represents a true option value if text then text textlower if text on or text yes then return true end end return false end local function fromentext input is a string representing a number in en digits with decimal mark without digit grouping which is done just after calling this return the translation of the string with numdot and digits in local language if numdot then text textgsub numdot end if fromentable then text textgsubd fromentable end return text end local function toentext input is a string representing a number in the local language with an optional numdot decimal mark and numsep digit grouping return the translation of the string with mark and en digits and no separators they have to be removed here to handle cases like numsep and numdot with input 1 234 567 8 if numsep then text textgsub numsep use x in case x is end if numdot then text textgsub numdot end if toentable then text ustring gsubtext d toentable end return text end local spellmodule name of module that can spell numbers local speller function from that module to handle spelling set if spelling is wanted local function setconfigframe set configuration options from template invoke or defaults config frame args numdot config numdot or decimal mark before fractional digits numsep config numsep or group separator for numbers maxsigfig config maxsigfig or 14 maximum number of significant figures scribunto sets the global variable mw a testing program can set the global variable istestrun local datamodule textmodule datacode if istestrun then local langcode mw language getcontentlanguage code datamodule convertdata langcode textmodule converttext langcode extramodule convertextra langcode spellmodule convertnumeric else local sandbox booleanconfig sandbox and sandbox or datamodule moduleconvertdata sandbox textmodule moduleconverttext sandbox extramodule moduleconvertextra sandbox spellmodule moduleconvertnumeric end datacode mw loaddatadatamodule textcode mw loaddatatextmodule defaultexceptions datacode defaultexceptions linkexceptions datacode linkexceptions allunits datacode allunits local translation textcode translationtable if translation then if translation group then groupmethod translation group end if translation perword then perword translation perword end if translation pluralsuffix then pluralsuffix translation pluralsuffix end varname translation varname fromentable translation fromen local useworkaround true if useworkaround then 20130705 workaround bug by making a copy of the required table mw ustring gsub fails with a table toentable as the replacement if the table is accessed via mw loaddata local source translation toen if source then toentable for k v in pairssource do toentablek v end end else toentable translation toen end end end local function collection return a table to hold items return n 0 add function self item self n self n 1 selfself n item end end local function dividenumerator denominator return integers quotient remainder resulting from dividing the two given numbers which should be unsigned integers local quotient remainder floornumerator denominator numerator denominator if not 0 remainder and remainder denominator then floating point limits may need this as in convert160 02ymydftin remainder 0 end return quotient remainder end local function splittext delimiter return a numbered table with fields from splitting text the delimiter is used in a regex without escaping for example would fail each field has any leadingtrailing whitespace removed local t text text delimiter to get last item for item in textgmatchs s delimiter do table insertt item end return t end local function striptext if text is a string return its content with no leadingtrailing whitespace otherwise return nil a nil argument gives a nil result if typetext string then return textmatchs s end end local function wantedcategorycat return cat if it is wanted in current namespace otherwise return nil this is so tracking categories only include pages that need correction local title mw title getcurrenttitle if title then local nsdefault 0 default namespace 0 article 0 10 article and template local namespace title namespace for v in ipairssplitconfig nscat or nsdefault do if namespace tonumberv then return cat end end end end local function messagemcode return wikitext for an error message including category if specified for the message type mcode numbered table specifying the message mcode1 cvtxxx string used as a key to get message info mcode2 parm1 string to replace first s if any in message mcode3 parm2 string to replace second s if any in message mcode4 parm3 string to replace third s if any in message local msg textcode allmessagesmcode1 local nowiki mw text nowiki if msg then local parts local regex replace msg regex msg replace for i 1 3 do local limit 40 local s mcodei 1 if s then if regex and replace then s sgsubregex replace limit nil allow long should be messages end escape user input so it does not break the message to avoid reference tags like convert1refxyzrefm or other tags breaking the mouseover title any strip marker starting with char127 is replaced with escaped ref ref or text not needing i18n local append local pos sfindstring char127 1 true if pos then if sfindref 1 true then append ltrefgt ltrefgt else append end s ssub1 pos 1 end if limit and ulens limit then s usubs 1 limit if append then append end end s nowikis append else s end partsi s end local title formatmsg1 or missing message parts1 parts2 parts3 local text msg2 or missing message local cat wantedcategorytextcode allcategoriesmsg3 or local anchor msg4 or local fmt textcode allmessagescvtformat or convert bug title titlegsub quot return formatfmt anchor title text cat end return convert internal error unknown message end local function addwarningparms level mcode text if enabled add a warning that will be displayed after the convert result to reduce output noise only the first warning is displayed if config warnings then if level tonumberconfig warnings or 1 then if parms warnings nil then parms warnings message mcode text end end end end local function spellnumberparms inout number numerator denominator return result of spelling number numerator denominator or return nil if spelling is not available or not supported for given text examples each value must be a string or nil number numerator denominator output 1 23 nil nil one point two three 1 2 3 one and two thirds nil 2 3 two thirds if not speller then local function getspellermodule return requiremodule spellnumber end local success success speller pcallgetspeller spellmodule if not success or typespeller function then addwarningparms 1 cvtnospell return nil end end local case if parms spellupper inout then case true parms spellupper nil only uppercase first word in a multiple unit end local sp not parms optspus local adj parms optadjectival return spellernumber numerator denominator case sp adj end begin code required only for builtin units later if need much more code move to another module to simplify this module local function speedofsoundaltitude this is for the mach builtin unit of speed return speed of sound in metres second at given altitude in feet if no altitude given use default zero altitude sea level table gives speed of sound in miles hour at various altitudes altitude 17 499 to 302 499 feet machtablea 4 s where a altitude 5000 rounded to nearest integer 3 to 60 s speed of sound mph at that altitude later should calculate result from an interpolation between the next lower and higher altitudes in table rather than rounding to nearest from httpwww aerospaceweb orgquestionatmosphereq0112 shtml local machtable a 799 5 787 0 774 2 761 207051 3 to 0 748 0 734 6 721 0 707 0 692 8 678 3 663 5 660 1 660 1 660 1 1 to 10 660 1 660 1 660 1 662 0 664 3 666 5 668 9 671 1 673 4 675 6 11 to 20 677 9 683 7 689 9 696 0 702 1 708 1 714 0 719 9 725 8 731 6 21 to 30 737 3 737 7 737 7 736 2 730 5 724 6 718 8 712 9 707 0 701 1 31 to 40 695 0 688 9 682 8 676 6 670 4 664 1 657 8 652 9 648 3 643 7 41 to 50 639 1 634 4 629 6 624 8 620 0 615 2 613 2 613 2 613 2 613 5 51 to 60 altitude altitude or 0 local a altitude 0 and altitude or altitude a floora 5000 0 5 if altitude 0 then a a end if a 3 then a 3 elseif a 60 then a 60 end return machtablea 4 0 44704 mph converted to ms end end code required only for builtin units local function checkmismatchunit1 unit2 if unit1 cannot be converted to unit2 return an error message table this allows conversion between units of the same type and between nm normally torque and ftlb energy as in gunrelated articles this works because nm is the base unit scale 1 for both the primary type torque and the alternate type energy where nm j a match occurs if the primary types are the same or if unit1 matches the alternate type of unit2 and vice versa that provides a whitelist of which conversions are permitted between normally incompatible types if unit1 utype unit2 utype or unit1 utype unit2 alttype and unit1 alttype unit2 utype then return nil end return cvtmismatch unit1 utype unit2 utype end local function overridefromouttable intable fields copy the specified fields from intable to outtable but do not copy nil fields keep any corresponding field in outtable for field in ipairsfields do if intablefield then outtablefield intablefield end end end local function shallowcopyt return a shallow copy of table t do not need the features and overhead of the scribunto mw clone local result for k v in pairst do resultk v end return result end local unitmt metatable to get missing values for a unit that does not accept si prefixes or for a unit that accepts prefixes but where no prefix was used in the latter case and before use fields symbol name1 name1us must be set from symbol name1 name1us respectively warning the boolean value false is returned for any missing field so index is not called twice for the same field in a given unit index function self key local value if key name1 or key symus then value self symbol elseif key name2 then value self name1 pluralsuffix elseif key name1us then value self name1 if not rawgetself name2us then if name1us is foot do not make name2us by appending pluralsuffix self name2us self name2 end elseif key name2us then local raw1us rawgetself name1us if raw1us then value raw1us pluralsuffix else value self name2 end elseif key link then value self name1 else value false end rawsetself key value return value end local unitprefixedmt metatable to get missing values for a unit that accepts si prefixes and where a prefix has been used before use fields siname siprefix must be defined index function self key local value if key symbol then value self siprefix self symbol elseif key symus then value self symbol always the same as symus for prefixed units elseif key name1 then prefixposition is a byte not character position so use luas sub local pos rawgetself prefixposition or 1 value self name1 value valuesub1 pos 1 self siname valuesubpos elseif key name2 then value self name1 pluralsuffix elseif key name1us then value rawgetself name1us if value then local pos rawgetself prefixposition or 1 value valuesub1 pos 1 self siname valuesubpos else value self name1 end elseif key name2us then if rawgetself name1us then value self name1us pluralsuffix else value self name2 end elseif key link then value self name1 else value false end rawsetself key value return value end local unitpermt metatable to get values for a unit of form xy this is never called to determine a unit name or link because units are handled as a special case index function self key local value if key symbol then local self local unit1 unit2 per1 per2 if unit1 then value unit1key unit2key else value unit2key end elseif key symus then value self symbol elseif key scale then local self local unit1 unit2 per1 per2 value unit1 and unit1 scale or 1 self scalemultiplier unit2 scale else value false end rawsetself key value return value end local function lookupunitcode optspus what utable fails depth return true t where t is a copy of the units converter table or return false t where t is an error message table parameter optspus is true for us spelling of si prefixes and the symbol and name of the unit if true the result includes field spus true that field may also have been in the unit definition parameter what determines whether combination units are accepted nocombination single unit only anycombination single unit or combination or output multiple onlymultiple single unit or output multiple only parameter unitcode is a symbol like g with an optional si prefix like kg if for example kg is in this table that entry is used otherwise the prefix k is applied to the base unit g if unitcode is a known combination code and if allowed by what a table of output multiple unit tables is included in the result for compatibility with the old template an underscore in a unitcode is replaced with a space so usage like convert350boardfeet works wikignomes may also put two spaces or nbsp in combinations so replace underscore nbsp and multiple spaces with a single space utable utable or allunits fails fails or depth depth and depth 1 or 1 if depth 9 then there are ways to mistakenly define units which result in infinite recursion when lookup is called that gives a long delay and very confusing error messages so the depth parameter is used as a guard return false cvtlookup unitcode end if unitcode nil or unitcode then return false cvtnounit end unitcode unitcodegsub gsubnbsp gsub local t utableunitcode if t then if t shouldbe then return false cvtshouldbe t shouldbe end local forcespus optspus if t spus then forcespus true optspus true end local target t target nil or unitcode is an alias for this target if target then local success result lookuptarget optspus what utable fails depth if not success then return false result end overridefromresult t customary default link symbol symlink local multiplier t multiplier if multiplier then result multiplier tostringmultiplier result scale result scale multiplier end return true result end local t nilfalse or a numbered table for xy units if then local result utype t utype result scalemultiplier t multiplier or 1 overridefromresult t invert iscomplex default link symbol symlink result symbolraw result symbol or false to distinguish between a defined exception and a metatable calculation local cvt result local prefix for i v in ipairsper do if i 1 and textcode currencyv then prefix v else local success t lookupv optspus nocombination utable fails depth if not success then return false t end cvti t if t spus then if the top or bottom unit forces spus set the unit to use the correct namesymbol forcespus true end end end if prefix then result vprefix prefix else result vprefix false to avoid calling index end result spus forcespus return true setmetatableresult unitpermt end local combo t combination nil or a table of unitcodes if combo then local multiple t multiple if what nocombination or what onlymultiple and not multiple then return false cvtbadunit unitcode end recursively create a combination table containing the converter table of each unitcode local result utype t utype multiple multiple combination local cvt result combination for i v in ipairscombo do local success t lookupv optspus multiple and nocombination or onlymultiple utable fails depth if not success then return false t end cvti t end return true result end local result shallowcopyt result spus forcespus if result prefixes then result symbol result symbol result name1 result name1 result name1us result name1us end return true setmetatableresult unitmt end local siprefixes textcode siprefixes for plen siprefixes1 or 2 1 1 do look for an si prefix should never occur with an alias check for longer prefix first dam is decametre siprefixes1 prefix maximum characters as seen by mw ustring sub local prefix usubunitcode 1 plen local si siprefixesprefix if si then local t utableusubunitcode plen1 if t and t prefixes then local result shallowcopyt if optspus then result spus true end if result spus and si nameus then result siname si nameus else result siname si name end result siprefix si prefix or prefix result scale t scale 10 si exponent t prefixes return true setmetatableresult unitprefixedmt end end end accept any unit with an engineering notation prefix like e6cuft million cubic feet but not chained prefixes like e3e6cuft and not if the unit is a combination or multiple and not if the unit has an offset or is a builtin only en digits are accepted local hasplus unitcodefind 1 true if not hasplus then local exponent baseunit unitcodematched if exponent then local engscale textcode engscalesexponent if engscale then local success result lookupbaseunit optspus nocombination utable fails depth if not success then return false result end if not result offset or result builtin or result engscale then result defkey unitcode key to lookup default exception result engscale engscale result scale result scale 10 tonumberexponent return true result end end end end accept userdefined combinations like acrem2ha or acre m2 ha for output if is used each unit code can include a space and any error is fatal if is used and if each spaceseparated word is a unit code it is a combo but errors are not fatal so the unit code can be looked up as an extra unit local errisfatal local combo collection if hasplus then errisfatal true for item in unitcode gmatchs s do if item then comboadditem end end elseif unitcodefinds then for item in unitcodegmatchs do comboadditem end end if combo n 1 then local function lookupcombo if what nocombination or what onlymultiple then return false cvtbadunit unitcode end local result combination local cvt result combination for i v in ipairscombo do local success t lookupv optspus onlymultiple utable fails depth if not success then return false t end if i 1 then result utype t utype else local mismatch checkmismatchresult t if mismatch then return false mismatch end end cvti t end return true result end local success result lookupcombo if success or errisfatal then return success result end end if not extraunits then local success extra pcallfunction return requireextramodule extraunits end if success and typeextra table then extraunits extra end end if extraunits then a unit in one data table might refer to a unit in the other table so switch between them relying on fails or depth to terminate loops if not failsunitcode then failsunitcode true local other utable allunits and extraunits or allunits local success result lookupunitcode optspus what other fails depth if success then return true result end end end return false cvtunknown unitcode end local function validnumbernum return true if num is a valid number in scribunto different from some standard lua when expressed as a string overflow or other problems are indicated with text like inf or nan which are regarded as invalid here each contains n if typenum number and tostringnumfindn 1 true nil then return true end end local function ntshnum debug return html text to be used for a hidden sort key so that the given number will be sorted in numeric order if debug true output is in a box not hidden this implements templatentsh number table sorting hidden local result style if not validnumbernum then if num 0 then result 1000000000000000000 else result 9000000000000000000 end elseif num 0 then result 5000000000000000000 else local mag floorlog10absnum 1e14 local prefix if num 0 then prefix 7000 mag else prefix 2999 mag num num 10mag1 end result formatd prefix format015 0f floornum 1014mag end if debug then style border1px solid else style displaynone end return span style style result span end local function hyphenatedname parts return a hyphenated form of given name for adjectival usage the name may be linked and the target of the link must not be changed hypothetical examples long tonton long tonton no change tonnelong ton tonnelongton metric tonlong ton metric tonlongton long ton long tonlongton input can also have multiple links in a single name like united states customary unitsu s us gallongallon miles united states customary unitsu s quart long tons short ton assume that links cannot be nested never like abcdefghi this uses a simple and efficient procedure that works for most cases some units if used would require more and can later think about adding a method to handle exceptions the procedure is to replace each space with a hyphen but not a space after for pre1954nbspus nautical mile and not spaces immediately before or in for cases like british thermal unit iso and calorie international steam table if namefind 1 true then if parts then local pos if namesub1 1 then pos namefind 1 true if pos then return namesub1 pos1 namesubpos2gsub end elseif namesub1 1 then pos namefind 1 true if pos then return namesub1 pos2gsub namesubpos1 end end return namegsub end parts collection for before item after in namegmatch do if itemfind 1 true then local prefix local plen itemfind 1 true if plen then prefix itemsub1 plen item itemsubplen 1 3 else prefix itemsub1 3 item itemsub3 3 end item prefix hyphenateditem parts end partsaddbeforegsub item aftergsub end if parts n 0 then no link like was found in the original name partsaddhyphenatedname parts end return table concatparts end return name end local function hyphenatedmaybeparms wantname sep id inout return s f where s id possibly modified f true if hyphenated possible modifications hyphenate prepend append mid text if id nil or id then return end local mid if parms optadjectival then if inout parms optflip and out or in then mid parms mid end if wantname then return hyphenatedid mid or true end end return sep id mid or end local function changesigntext change sign of text for correct appearance because it is negated if textsub1 1 then return textsub2 end return text end local function useminustext return text with unicode minus instead of if present if textsub1 1 then return minus textsub2 end return text end local function digitgroupermethod gaps return a table to hold groups of digits which can be joined with suitable separators such as commas each group is separately translated to the local language because gap separators include digits which should not be translated parameter method is a number or nil 3 for 3digit grouping or 2 for 3then2 grouping parameter gaps is true to use span gaps numsep ignored return n 0 add function self digits self n self n 1 selfself n fromendigits end join function self rhs concatenate in reverse order if gaps then local result for i 1 self n 1 do result span stylemarginleft 0 25em selfi span result end return span stylewhitespace nowrap selfself n result fromenrhs span else local result self1 for i 2 self n do result selfi numsep result end return result fromenrhs end end step 3 nextposition function self previous return position of digit just before next group digits are grouped from righttoleft least significant first local result previous self step if method 2 then self step 2 end return result 0 and 0 or result end end local function withseparatorparms text input text is a number in en digits and optional decimal mark return an equivalent of text formatted for display with a custom decimal mark instead of if wanted with thousand separators inserted if wanted digits in local language the given text is like 123 or 12345 6789 or 1 23e45 e notation can only occur when processing an input value the text has no sign caller inserts that later if necessary separator is inserted only in the integer part of the significand not after the decimal mark and not after e or e if parms optnocomma or numsep then return fromentext end local last textmatch ee returns position if last nil then last text else last last 1 index of last character before dotee end if last 4 or last 4 and parms optcomma5 then return fromentext end local groups digitgroupergroupmethod parms optgaps local i last while i 0 do local position groupsnextpositioni groupsaddtextsubposition1 i i position end return groupsjointextsublast1 end input values can use values like 1 23e12 but are never displayed using scientific notation like 1 2310 very small or very large output values use scientific notation use formatfmtpower significand 10 exponent where each arg is a string local fmtpower sspan stylemargin0 15em 0 25emspanssupssup local function withexponentshow exponent return wikitext to display the implied value in scientific notation input uses en digits output uses digits in local language if show 1 then show showsub1 1 showsub2 end return formatfmtpower fromenshow fromen10 useminusfromentostringexponent end local function makesigfigvalue sigfig return show exponent that are equivalent to the result of converting the number value where value 0 to a string rounded to sigfig significant figures the returned items are show a string of digits no sign and no dot there is an implied dot before show exponent a number an integer to shift the implied dot resulting value tonumber show 10exponent examples makesigfig23 456 3 returns 235 2 235 102 makesigfig0 0023456 3 returns 235 2 235 102 makesigfig0 3 returns 000 1 000 101 if sigfig 0 then sigfig 1 elseif sigfig maxsigfig then sigfig maxsigfig end if value 0 then return string rep0 sigfig 1 end local exp fracpart math modflog10value if fracpart 0 then fracpart fracpart 1 exp exp 1 end local digits format 0f 10fracpart sigfig if digits sigfig then overflow for sigfig3 like 0 9999 rounding to 1000 need 100 digits digitssub1 sigfig exp exp 1 end assertdigits sigfig bug rounded number has wrong length return digits exp end fraction output format local fracfmt like frac fraction slash 12 sign numerator denominator 123 signedwholenumber numerator denominator span classfrac nowrapssupssupfraslsubssubspan span classfrac nowrapsspan classvisualhidenbspspansupssupfraslsubssubspan like sfrac fraction horizontal bar 12 sign numerator denominator sign should probably be before the fraction but then it can wrap and html is already too long 123 signedwholenumber numerator denominator span classsfrac nowrap styledisplayinlineblock verticalalign0 5em fontsize85 textaligncenterspan styledisplayblock lineheight1em padding0 0 1emssspanspan classvisualhidespanspan styledisplayblock lineheight1em padding0 0 1em bordertop1px solidsspanspan span classsfrac nowrapsspan classvisualhidenbspspanspan styledisplayinlineblock verticalalign0 5em fontsize85 textaligncenterspan styledisplayblock lineheight1em padding0 0 1emsspanspan classvisualhidespanspan styledisplayblock lineheight1em padding0 0 1em bordertop1px solidsspanspanspan local function formatfractionparms inout negative wholestr numstr denstr dospell style return wikitext for a fraction possibly spelled inputs use en digits and have no sign output uses digits in local language local wikitext if not style then style parms optfractionhorizontal and 2 or 1 end if wholestr then wholestr nil end if wholestr then local decorated withseparatorparms wholestr if negative then decorated minus decorated end local fmt fracfmtstyle2 wikitext formatfmt decorated fromennumstr fromendenstr else local sign negative and minus or wikitext formatfracfmtstyle1 sign fromennumstr fromendenstr end if dospell then if negative then if wholestr then wholestr wholestr else numstr numstr end end wikitext spellnumberparms inout wholestr numstr denstr or wikitext end return wikitext end local function formatnumberparms show exponent isnegative parameter show is a string or a table containing strings each string is a formatted number in en digits and optional decimal mark a table represents a fraction integer numerator denominator if a table is given exponent must be nil return t where t is a table with fields show wikitext formatted to display implied value digits in local language isscientific true if show uses scientific notation clean unformatted show possibly adjusted and with inserted en digits sign or minus exponent exponent possibly adjusted the clean and exponent fields can be used to calculate the rounded absolute value if needed the value implied by the arguments is found from exponent is nil and show is a string of digits no sign with an optional dot show 123 4 is value 123 4 1234 is value 1234 0 or exponent is an integer indicating where dot should be show is a string of digits no sign and no dot there is an implied dot before show show does not start with 0 show 1234 exponent 3 is value 0 1234103 123 4 the formatted result is for an output value and is spelled if wanted and possible includes a unicode minus if isnegative and not spelled uses a custom decimal mark if wanted has digits grouped where necessary if wanted uses scientific notation for very small or large values which forces output to not be spelled has no more than maxsigfig significant digits same as old template and expr local sign isnegative and minus or local maxlen maxsigfig local tfrac if typeshow table then tfrac show show tfrac wholestr assertexponent nil bug exponent given with fraction end if not tfrac and not exponent then local integer dot decimals showmatchd if integer 10 then show integer decimals exponent integer elseif integer 0 or integer then local zeros figs decimalsmatch00 if figs 0 then if zeros maxlen then show 0 zerossub1 maxlen end elseif zeros 4 then show figs exponent zeros elseif figs maxlen then show 0 zeros figssub1 maxlen end else maxlen maxlen dot if show maxlen then show showsub1 maxlen end end end if exponent then if show maxlen then show showsub1 maxlen end if exponent 10 or exponent 4 or exponent 10 and show 1000000000 then rounded value satisfies value 1e9 or value 1e4 1e9 0 1e10 return clean show exponent exponent sign sign show sign withexponentshow exponent1 isscientific true end if exponent show then show show string rep0 exponent show result has no dot elseif exponent 0 then show 0 string rep0 exponent show else show showsub1 exponent showsubexponent1 end end local formattedshow if tfrac then show tostringtfrac value to set clean in returned table formattedshow formatfractionparms out isnegative tfrac wholestr tfrac numstr tfrac denstr parms optspellout else if isnegative and showmatch0 0 then sign dont show minus if result is negative but rounds to zero end formattedshow sign withseparatorparms show if parms optspellout then formattedshow spellnumberparms out sign show or formattedshow end end return clean show sign sign show formattedshow isscientific false to avoid calling index end local function extractfractionparms text negative if text represents a fraction return value altvalue show spelled denominator where value is a number value of the fraction in argument text altvalue is an alternate interpretation of any fraction for the hands unit where 14 134 means 14 hands 1 75 inches show is a string formatted text for display of an input value and is spelled if wanted and possible spelled is true if show was spelled denominator is value of the denominator in the fraction otherwise return nil input uses en digits and decimal mark input has been translated output uses digits in local language and custom decimal mark if any in the following 38 represents the wikitext required to display a fraction with numerator 3 and denominator 8 in the wikitext unicode minus is used for a negative value text value show value show if not negative if negative 3 8 0 375 38 0 375 38 2 3 8 2 375 238 1 625 238 2 3 8 1 625 238 2 375 238 1 208 3 5 1208 1 5 1208 1 208 1 5 1208 3 5 1208 wherever an integer appears above numbers like 1 25 or 12 5e3 which may be negative are also accepted like old template old template interprets 1 23e21224 as 1231224 123 5 local numstr whole value altvalue local lhs slash denstr textmatchsss s local denominator tonumberdenstr if denominator nil then return nil end local wholestr negfrac rhs lhsmatchs eess s if wholestr nil or wholestr then wholestr nil whole 0 numstr lhs else whole tonumberwholestr if whole nil then return nil end numstr rhs end negfrac negfrac local numerator tonumbernumstr if numerator nil then return nil end spelling of silly inputs like 238 or 238 mixed or excess signs is not supported local dospell if negative negfrac or wholestr nil then value whole numerator denominator altvalue whole numerator denominator 10 dospell parms optspellin if dospell then if not numstrmatchd and denstrmatchd then if either has a sign dospell false end end else value whole numerator denominator altvalue whole numerator denominator 10 numstr changesignnumstr dospell false end if not validnumbervalue then return nil overflow or similar end numstr useminusnumstr denstr useminusdenstr local style slash kludge 1 or 2 slashes can be used to select style if style 2 then style 2 end local wikitext formatfractionparms in negative wholestr numstr denstr dospell style return value altvalue wikitext dospell denominator end local function extractnumberparms text another nofraction return true info if can extract a number from text where info is a table with the result or return false t where t is an error message table input can use en digits or digits in local language parameter another true if the expected value is not the first before processing the input text is cleaned any thousand separators valid or not are removed any sign and optional following whitespace is replaced with if negative or otherwise that replaces unicode minus with if successful the returned info table contains named fields value a valid number altvalue a valid number usually same as value but different if fraction used for hands unit singular true if value is 1 to use singular form of units false if value is 1 like old template clean cleaned text with any separators and sign removed en digits and decimal mark show text formatted for output digits in local language and custom decimal mark the resulting show is for an input value and is spelled if wanted and possible has a rounded value if wanted has digits grouped where necessary if wanted if negative a unicode minus is used otherwise the sign is if the input text used or is if no sign in input text striptext or local clean toentext if clean then return false another and cvtnonum2 or cvtnonum end local isnegative propersign false most common case local singular show denominator local value tonumberclean local altvalue if value then local sign cleansub1 1 if sign or sign then propersign sign and or minus clean cleansub2 end if value 0 then isnegative true value value end else local valstr for prefix in ipairs minus minus do including means inputs like 2 with space are accepted as 2 it also sets isnegative in case input is a fraction like 234 local plen prefix if cleansub1 plen prefix then valstr cleansubplen 1 break end end if valstr then isnegative true propersign minus clean valstr value tonumberclean end if value nil then local spelled if not nofraction then value altvalue show spelled denominator extractfractionparms clean isnegative end if value nil then return false cvtbadnum text end if value 1 then singular true for example mile or one half mile singular unit end end end if not validnumbervalue then for example 1e310 may overflow return false cvtinvalidnum end if show nil then singular value 1 and not isnegative local precision parms inputprecision if precision and 0 precision and precision 8 then local fmt formatd precision f show fmtformatvalue 2e14 fudge for some common cases of bad rounding else show clean end show propersign withseparatorparms show if parms optspellin then show spellnumberparms in propersign clean or show end end local altvalue altvalue or value if isnegative and value 0 then value value altvalue altvalue end return true value value altvalue altvalue singular singular clean clean show show denominator denominator end local function getnumbertext return v f where v nil text is not a number or v value of text text is a number f true if value is an integer input can use en digits or digits in local language but no separators no unicode minus and no fraction if text then local number tonumbertoentext if number then local integer fracpart math modfnumber return number fracpart 0 end end end local function gcda b return the greatest common denominator for the given values which are known to be positive integers if a b then a b b a end if a 0 then return b end local r b a if r 0 then return a end if r 1 then return 1 end return gcdr a end local function fractiontablevalue denominator return value as a string or a table if result is a string there is no fraction and the result is value formatted as a string of en digits if result is a table it represents a fraction with named fields wholestr numstr denstr strings of en digits for integer numerator denominator the result is rounded to the nearest multiple of 1denominator if the multiple is zero no fraction is included no fraction is included if value is very large as the fraction would be unhelpful particularly if scientific notation is required input value is a nonnegative number input denominator is a positive integer for the desired fraction if value 0 then return 0 end if denominator 0 or value 1e8 then return format 2f value end local integer decimals math modfvalue local numerator floordecimals denominator 0 5 2e14 add fudge for some common cases of bad rounding if numerator denominator then integer integer 1 numerator 0 end local wholestr tostringinteger if numerator 0 then local div gcdnumerator denominator if div 1 then numerator numerator div denominator denominator div end return wholestr integer 0 and wholestr or numstr tostringnumerator denstr tostringdenominator value value end return wholestr end local function preunitscount preunit1 preunit2 if count is 1 ignore preunit2 return p1 else preunit1 is used for preunit2 if the latter is empty return p1 p2 where p1 is text to insert before the input unit p2 is text to insert before the output unit p1 or p2 may be nil to mean no preunit using gives output like 5 feet no preceding space local function withspacetext i insert space at beginning if i 1 or at end if i 1 however no space is inserted if there is a space or nbsp or at that position is for adjectival text local current textsubi i if current or current then return text end if i 1 then current textsub1 6 else current textsub6 1 end if current nbsp then return text end if i 1 then return text end return text end preunit1 preunit1 or local trim1 strippreunit1 if count 1 then if trim1 then return nil end return withspacewithspacepreunit1 1 1 end preunit2 preunit2 or local trim2 strippreunit2 if trim1 and trim2 then return nil nil end if trim1 then preunit1 withspacepreunit1 1 end if trim2 32 then trick to make preunit2 empty preunit2 nil elseif trim2 then preunit2 preunit1 elseif trim2 then preunit2 withspacepreunit2 1 end return preunit1 preunit2 end local function rangetextrange wantname parms before after return before rtext after where rtext is the text that separates two values in a range local rtext adjtext exception if typerange table then table must specify range text for abbroff and for abbron and may specify range text for adjon and may specify exception true rtext rangewantname and off or on adjtext rangeadj exception rangeexception else rtext range end if parms optadjectival then if wantname or exception and parms abbrorg on then rtext adjtext or rtextgsub gsubnbsp end end if rtext and aftersub1 minus minus then rtext nbsp end return before rtext after end local function getcompositeparms iparm total inunittable look for a composite input unit for example convert1yd2ft3in would result in a call to this function with iparm 3 parmsiparm 2 just after the first unit total 1 number of yards inunittable unit table for yd return true iparm unit where iparm index just after the composite units 7 in above example unit composite unit table holding all input units or return true if no composite unit is present in parms or return false t where t is an error message table local default subinfo local compositeunits count inunittable 1 local fixups local subunit inunittable while subunit subdivs do subdivs is nil or a table of allowed subdivisions local subcode stripparmsiparm1 local subdiv subunit subdivssubcode if not subdiv then break end local success success subunit lookupsubcode parms optspus nocombination if not success then return false subunit end should never occur success subinfo extractnumberparms parmsiparm if not success then return false subinfo end iparm iparm 2 subunit inout in subunit valinfo subinfo recalculate total as a number of subdivisions subdiv1 number of subdivisions previous unit integer 1 total total subdiv1 subinfo value if not default then set by the first subdiv with a default defined default subdiv default end count count 1 compositeunitscount subunit if subdiv unit or subdiv name then fixupscount unit subdiv unit name subdiv name valinfo subunit valinfo end end if count 1 then return true no error and no composite unit end for i fixup in pairsfixups do local unit fixup unit local name fixup name if not unit or count 2 and name then compositeunitsi fixedname name else local success alternate lookupunit parms optspus nocombination if not success then return false alternate end should never occur alternate inout in alternate valinfo fixup valinfo compositeunitsi alternate end end return true iparm utype inunittable utype scale subunit scale scale of last least significant unit valinfo value total clean subinfo clean denominator subinfo denominator composite compositeunits default default or inunittable default end local function translateparmsparms kvpairs update fields in parms by translating each keyvalue in kvpairs to terms used by this module may involve translating from local language to english also checks are performed which may display warnings if enabled return true if successful or return false t where t is an error message table if kvpairs adj and kvpairs sing then for en wiki before translation warn if attempt to use adj and sing as the latter is a deprecated alias for the former if kvpairs adj kvpairs sing and kvpairs sing then addwarningparms 1 cvtunknownoption sing kvpairs sing end kvpairs sing nil end for locname locvalue in pairskvpairs do local enname textcode enoptionnamelocname if enname then local envalue if enname frac or enname sigfig then if locvalue then addwarningparms 2 cvtemptyoption locname else local minimum local number isinteger getnumberlocvalue if enname frac then minimum 2 if number and number 0 then parms optfractionhorizontal true number number end else minimum 1 end if number and isinteger and number minimum then envalue number else addwarningparms 1 enname frac and cvtbadfrac or cvtbadsigfig locvalue end end else envalue textcode enoptionvalueennamelocvalue if envalue nil then if locvalue then addwarningparms 2 cvtemptyoption locname else locvalue can no longer be nil here at one time that could occur with aliases like singoffadjon but am retaining safety check local text locvalue and locname locvalue or locname addwarningparms 1 cvtunknownoption text end elseif envalue then envalue nil an ignored option like adjoff elseif typeenvalue string and envaluesub1 4 opt then for v in ipairssplitenvalue do parmsv true end envalue nil end end parmsenname envalue else addwarningparms 1 cvtunknownoption locname locvalue end end if parms adj then if parms adjsub1 2 ri then it is known that adj is rin where n is a single digit so precision is valid only a single en digit is accepted parms inputprecision tonumberparms adjsub1 parms adj nil end end local cfgabbr config abbr if cfgabbr then if cfgabbr on always then parms abbr on elseif cfgabbr on default then if parms abbr nil then parms abbr on end end end if parms abbr then parms abbrorg parms abbr original abbr that was set before any flip elseif parms opthandhh then parms abbrorg on parms abbr on else parms abbr out default is to abbreviate output only use symbol not name end if parms optflip then local function swapinoutoption local value parmsoption if value in then parmsoption out elseif value out then parmsoption in end end swapinoutabbr swapinoutlk if parms optspellin and not parms optspellout then for simplicity and because it does not appear to be needed user cannot set an option to spell the output only parms optspellin nil parms optspellout true end end if parms optspellupper then parms spellupper parms optflip and out or in end if parms opttable or parms opttablecen then if parms abbrorg nil and parms lk nil then parms optvalues true end local align formataligns parms opttable and right or center parms tablejoins align n align end if parms optlangen then fromentable nil end return true end local function getvaluesparms if successful update parms and return true v i where v table of input values i index to next entry in parms after those processed here or return false t where t is an error message table local ranges textcode ranges local valinfo collection numbered table of input values local range collection numbered table of range items having for example 2 range items requires 3 input values local hadnocomma true if removed nocomma kludge from second parameter like tonocomma local parm2 stripparms2 if parm2 and parm2sub7 1 nocomma then parms2 stripparm2sub1 8 parms optnocomma true hadnocomma true end local function extractori if the parameter is not a value try unpacking it as a range 123 for 1 to 23 however 123 is a negative fraction 1 so it must be extracted first unpacked items are inserted into the parms table local valstr stripparmsi trim so any as a negative sign will be at start local success result extractnumberparms valstr i 1 if not success and valstr and i 20 then check i to limit abuse for sep in ipairsranges words do local start stop valstrfindsep 2 true start at 2 to skip any negative sign for range if start then parmsi valstrsubstop 1 table insertparms i sep table insertparms i valstrsub1 start 1 return extractori this allows combinations like 1 x 2 to 3 x 4 end end end return success result end local i 1 local ischange while true do local success info extractori need to set parms optnocomma before calling this if not success then return false info end i i 1 if ischange then info ischange true value is after and so is a change significant for range like convert55c ischange nil end valinfoaddinfo local next stripparmsi local rangeitem ranges typesnext or ranges typesranges aliasesnext if not rangeitem then break end i i 1 rangeaddrangeitem if typerangeitem table then parms israngex rangeitem israngex ischange rangeitem israngechange end end if range n 0 then if range n 30 then limit abuse although 4 is a more likely upper limit return false cvtinvalidnum misleading message but it will do end parms range range elseif hadnocomma then return false cvtunknown parm2 end return true valinfo i end local function simplegetvaluesparms if input is like convertvalidvaluevalidunit return true v 3 inunit inunittable as for getvalues but with a unit name and table for a valid unit 3 index in parms of whatever follows validunit if anything the validvalue is not negative and does not use a fraction and no options requiring further processing of the input are used otherwise return nothing and caller will reparse the input testing shows this function is successful for 96 of converts in articles and that on average it speeds up converts by 8 if parms inputprecision or parms optspellin then return end local clean toenstripparms1 or if clean 10 or not cleanmatch09 then return end local value tonumberclean if not value then return end local info value value altvalue value singular value 1 clean clean show withseparatorparms clean local inunit stripparms2 local success inunittable lookupinunit parms optspus nocombination if not success then return end return true info 3 inunit inunittable end local function getparmspframe if successful return true parms unit where parms is a table of all arguments passed to the template converted to named arguments and unit is the input unit table or return false t where t is an error message table the returned input unit table may be for a fake unit using the specified unit code as the symbol and name and with badmcode message code table mediawiki removes leading and trailing whitespace from the values of named arguments however the values of numbered arguments include any whitespace entered in the template and whitespace is used by some parameters example the numbered parameters associated with dispx local parms arguments passed to template after translation local kvpairs table of input keyvalue pairs where key is a name needed because cannot iterate parms and add new fields to it for k v in pairspframe args do if typek number or k test then parameter test is reserved for testing and is not translated parmsk v else kvpairsk v end end local success msg translateparmsparms kvpairs if not success then return false msg end local success valinfo i inunit inunittable simplegetvaluesparms if not success then success valinfo i getvaluesparms if not success then return false valinfo end inunit stripparmsi i i 1 success inunittable lookupinunit parms optspus nocombination if not success then if inunit nil then inunit end if parms optignoreerror then display given unit code with no error for use with val inunittable nil end inunittable setmetatable symbol inunit name2 inunit utype length scale 1 badmcode inunittable default m unitmt end end if parms test msg then am testing the messages produced when no output unit is specified and the input unit has a missing or invalid default set two units for testing that later remove this code if inunit chain then inunittable default nil no default elseif inunit rd then inunittable default ftxm an invalid expression end end inunittable valinfo valinfo inunittable inout in this is an input unit if not parms range then local success inext compositeunit getcompositeparms i valinfo1 value inunittable if not success then return false inext end if compositeunit then inunittable compositeunit i inext end end if inunittable builtin mach then as with old template a number following mach as the input unit is the altitude and there is no way to specify an altitude for the output unit could put more code in this function to get any output unit and check for an altitude following that unit local success info extractnumberparms parmsi false true if success then i i 1 inunittable altitude info value end end local next stripparmsi i i 1 local precision isbadprecision local function setprecisiontext local number isinteger getnumbertext if number then if isinteger then precision number else precision text isbadprecision true end return true text was used for precision good or bad end end if not setprecisionnext then parms outunit next if setprecisionstripparmsi then i i 1 end end if parms optadjmid then parms optadjectival true next parmsi i i 1 if next then midtext words if nextsub1 1 then parms mid next else parms mid next end end end if parms optonepreunit then parmsparms optflip and preunit2 or preunit1 preunits1 parmsi i i 1 end if parms disp x then following is reasonably compatible with the old template local first parmsi or local second parmsi1 or i i 2 if stripfirst then user can enter 32 rather than to avoid the default first nbsp first second nbsp second end parms joins first second elseif parms opttwopreunits then local p1 p2 preunits2 parmsi parmsi1 i i 2 if parms preunit1 then to simplify documentation allow unlikely use of adjpre with disppreunit however an output unit must be specified with adjpre and with disppreunit parms preunit1 parms preunit1 p1 parms preunit2 p2 else parms preunit1 parms preunit2 p1 p2 end end if precision nil then if setprecisionstripparmsi then i i 1 end end if isbadprecision then addwarningparms 1 cvtbadprec precision else parms precision precision end return true parms inunittable end local function recorddefaultprecisionparms outcurrent precision if necessary adjust parameters and return a possibly adjusted precision when converting a range of values where a default precision is required that default is calculated for each value because the result sometimes depends on the precise input and output values this function may cause the entire convert process to be repeated in order to ensure that the same default precision is used for each individual convert if that were not done a range like 1000 to 1000 4 may give poor results because the first output could be heavily rounded while the second is not for range 1000 4 to 1000 this function can give the second convert the same default precision that was used for the first if not parms optroundeach then local maxdef outcurrent maxdefaultprecision if maxdef then if maxdef precision then parms doconvertagain true outcurrent maxdefaultprecision precision else precision outcurrent maxdefaultprecision end else outcurrent maxdefaultprecision precision end end return precision end local function defaultprecisionparms invalue inclean denominator outvalue incurrent outcurrent extra return a default value for precision an integer like 2 0 2 if denominator is not nil it is the value of the denominator in inclean code follows procedures used in old template local fudge 1e14 order of magnitude adds this so we do too local prec minprec adjust local utype outcurrent utype local subunitignoretrailingzero local subunitmoreprecision kludge for in used in input like 2ft6in local composite incurrent composite if composite then subunitignoretrailingzero true input 2st10lb has precision 0 not 1 if compositecomposite exception subunitmoreprecision then subunitmoreprecision true do not use standard precision with input like 2ft6in end end if denominator and denominator 0 then prec math maxlog10denominator 1 else count digits after decimal mark handling cases like 12 345e6 local exponent local integer dot decimals expstr incleanmatchd d local e expstrsub1 1 if e e or e e then exponent tonumberexpstrsub2 end if dot then prec subunitignoretrailingzero and 0 or integermatch0len else prec decimals end if exponent then so 1230 and 1 23e3 both give prec 1 and 0 00123 and 1 23e3 give 5 prec prec exponent end end if incurrent istemperature and outcurrent istemperature then converting between common temperatures c f r k not kevt mk kelvin value can be almost zero or small but negative due to precision problems also an input value like 300 c below absolute zero gives negative kelvins calculate minimum precision from absolute value adjust 0 local kelvin absinvalue incurrent offset incurrent scale if kelvin 1e8 then assume nonzero due to input or calculation precision problem minprec 2 else minprec 2 floorlog10kelvin fudge 3 sigfigs in kelvin end else if invalue 0 or outvalue 0 then we are never called with a negative outvalue but it might be zero this is specialcased to avoid calculation exceptions return recorddefaultprecisionparms outcurrent 0 end if outcurrent exception integermoreprecision and floorinvalue invalue then with certain output units that sometimes give poor results with default rounding use more precision when the input value is equal to an integer an example of a poor result is when input 50 gives a smaller output than input 49 5 experiment shows this helps but it does not eliminate all surprises because it is not clear whether 50 should be interpreted as from 45 to 55 or from 49 5 to 50 5 adjust log10incurrent scale elseif subunitmoreprecision then conversion like convert6ft1incm where subunit is in has a nonstandard adjust value to give more output precision adjust log10outcurrent scale 2 else adjust log10absinvalue outvalue end adjust adjust log102 ensure that the output has at least two significant figures minprec 1 floorlog10outvalue fudge end if extra then adjust extra adjust or adjust minprec extra minprec or minprec end return recorddefaultprecisionparms outcurrent math maxfloorprec adjust minprec end local function convertparms invalue info incurrent outcurrent convert given input value from one unit to another return outputvalue a number if a simple convert or return f t where f true t table of information with results or f false t error message table local inscale incurrent scale local outscale outcurrent scale if not incurrent iscomplex and not outcurrent iscomplex then return invalue inscale outscale minimize overhead for most common case end if incurrent invert or outcurrent invert then inverted units such as inverse length inverse time or fuel efficiency builtin units do not have invert set if incurrent invert or 1 outcurrent invert or 1 0 then return 1 invalue inscale outscale end return invalue inscale outscale elseif incurrent offset then temperature there are no builtins for this type of unit if info ischange then return invalue inscale outscale end return invalue incurrent offset inscale outscale outcurrent offset else builtin unit local inbuiltin incurrent builtin local outbuiltin outcurrent builtin if inbuiltin and outbuiltin then if inbuiltin outbuiltin then return invalue end there are no cases yet where need to convert from one builtin unit to another so this should never occur return false cvtbugconvert end if inbuiltin mach or outbuiltin mach then local adjust if inbuiltin mach then inscale speedofsoundincurrent altitude adjust outscale 0 1 else outscale speedofsoundoutcurrent altitude adjust 0 1 inscale end return true outvalue invalue inscale outscale adjust log10adjust log102 elseif inbuiltin hand then 1 hand 4 inches 1 2 hands 6 inches decimals of a hand are only defined for the first digit and the first fractional digit should be a number of inches 1 2 or 3 however this code interprets the entire fractional part as the number of inches 10 so 1 75 inches would be 0 175 hands a value like 12 3 hands is exactly 124 3 inches base default precision on that local integer fracpart math modfinvalue local inchvalue 4 integer 10 fracpart equivalent number of inches local factor inscale outscale if factor 4 then am converting to inches show exact result and use inches not in by default if parms abbrorg nil then outcurrent usename true end local show formatg absinchvalue show and clean are unsigned if not showfinde 1 true then return true invalue inchvalue outvalue inchvalue clean show show show end end local outvalue integer 2 5 fracpart factor local fracstr info cleanmatch or local fmt if fracstr then fmt 0f else fmt formatd fracstr 1 f end return true invalue inchvalue clean formatfmt inchvalue outvalue outvalue minprec 0 end end return false cvtbugconvert should never occur end local cvttohand local function cvtroundparms info incurrent outcurrent return true t where t is a table with the conversion results fields show rounded formatted string with the result of converting value in info using the rounding specified in parms singular true if result is positive and after rounding is 1 or like 1 00 and more fields shown below and a calculated absvalue field or return true nil if no value specified or return false t where t is an error message table input info clean uses en digits it has been translated if necessary output show uses en or nonen digits as appropriate or can be spelled local invalue if info then invalue info value if incurrent builtin hand then invalue info altvalue end end if invalue nil or invalue then return true nil end if outcurrent builtin hand then return cvttohandparms info incurrent outcurrent end local outvalue extra convertparms invalue info incurrent outcurrent if extra then if not outvalue then return false extra end invalue extra invalue or invalue outvalue extra outvalue end if not validnumberoutvalue then return false cvtinvalidnum end local isnegative if outvalue 0 then isnegative true outvalue outvalue end local numerator precision success show exponent local denominator outcurrent frac if denominator then show fractiontableoutvalue denominator else precision parms precision if not precision then local sigfig parms sigfig if sigfig then show exponent makesigfigoutvalue sigfig elseif parms optround5 or parms optround25 then local n parms optround5 and 5 or 25 show format 0f flooroutvalue n 0 5 n else local inclean info clean if extra then inclean extra clean or inclean show extra show end if not show then precision defaultprecisionparms invalue inclean info denominator outvalue incurrent outcurrent extra end end end end if precision then if precision 0 then local fudge if precision 8 then add a fudge to handle common cases of bad rounding due to inability to precisely represent some values this makes the following work convert100 1ck and convert5555000umm2 old template uses expr round which invokes php round later investigate how php round works fudge 2e14 else fudge 0 end local fmt formatd precision f local success success show pcallformat fmt outvalue fudge if not success then return false cvtbigprec tostringprecision end else precision precision digits to zero in addition to any digits after dot local shift 10 precision show format 0f outvalueshift if show 0 then exponent show precision end end end local t formatnumberparms show exponent isnegative set singular using match because on some systems 0 99999999999999999 is 1 0 t singular typeshow string and show 1 or showmatch1 0 nil and not isnegative t fractiontable typeshow table and show or nil t rawabsvalue outvalue absolute value before rounding return true setmetatablet index function self key if key absvalue then calculate absolute value after rounding if needed local clean exponent rawgetself clean rawgetself exponent local value tonumberclean absolute value any negative sign has been ignored if exponent then value value 10exponent end rawsetself key value return value end end end function cvttohandparms info incurrent outcurrent convert input to hands inches return true t where t is a table with the conversion results or return false t where t is an error message table if parms abbrorg nil then outcurrent usename true default is to show name not symbol end local precision parms precision local frac outcurrent frac if not frac and precision and precision 1 then frac precision 2 and 2 or 4 end local outnext outcurrent outnext if outnext then use magic knowledge to determine whether the next unit is inches without requiring i18n the following ensures that when the output combination hand in is used the inches value is rounded to match the hands value also displaying say 61 instead of 61 5 is better as 61 5 implies the value is not 61 4 if outnext exception subunitmoreprecision then outnext frac frac end end convert to inches calculate hands from that local dummyunittable scale outcurrent scale 4 frac frac local success outinfo cvtroundparms info incurrent dummyunittable if not success then return false outinfo end local tfrac outinfo fractiontable local inches outinfo rawabsvalue if tfrac then inches floorinches integer part only fraction added later else inches floorinches 0 5 a hands measurement never shows decimals of an inch end local hands inches divideinches 4 outinfo absvalue hands inches4 supposed to be the absolute rounded value but this is close enough local inchstr tostringinches 0 1 2 or 3 if precision and precision 0 then using negative or 0 for precision rounds to nearest hand hands flooroutinfo rawabsvalue4 0 5 inchstr elseif tfrac then always show an integer before fraction like 15 0 because 15 means 15andahalf hands inchstr numdot formatfractionparms out false inchstr tfrac numstr tfrac denstr else inchstr numdot fromeninchstr end outinfo show outinfo sign withseparatorparms format 0f hands inchstr return true outinfo end local function evaluateconditionvalue condition return true or false from applying a conditional expression to value or throw an error if invalid a very limited set of expressions is supported v 9 v 9 9 where v is replaced with value 9 is any number as defined by lua tonumber only en digits are accepted can also be or or in addition the following form is supported lhs and rhs where lhs rhs any of above expressions local function comparevalue text local arithop factor compop limit textmatchsvs if arithop nil then errorinvalid default expression 0 elseif arithop then factor tonumberfactor if factor nil then errorinvalid default expression 0 end value value factor end limit tonumberlimit if limit nil then errorinvalid default expression 0 end if compop then return value limit elseif compop then return value limit elseif compop then return value limit elseif compop then return value limit end errorinvalid default expression 0 should not occur end local lhs rhs conditionmatch wandw if lhs nil then return comparevalue condition end return comparevalue lhs and comparevalue rhs end local function getdefaultvalue unittable return true s where s name of units default output unit or return false t where t is an error message table some units have a default that depends on the input value the first value if a range of values is used if is in the default the first bangdelimited field is an expression that uses v to represent the input value example v 120 small big suffix suffix is optional evaluates v 120 as a boolean with result smallsuffix if value 120 or bigsuffix otherwise input must use en digits and decimal mark local default defaultexceptionsunittable defkey or unittable symbol or unittable default if not default then return false cvtnodefault unittable symbol end if defaultfind 1 true nil then return true default end local t splitdefault if t 3 or t 4 then local success result pcallevaluatecondition value t1 if success then default result and t2 or t3 if t 4 then default default t4 end return true default end end return false cvtbaddefault unittable symbol end local linkedpages to record linked pages so will not link to the same page more than once local function makelinklink id linkkey return wikilink linkid possibly abbreviated as in examples milemile mile milemiles miles however just id is returned if no link given so caller does not need to check if a link was defined or link has previously been used during the current convert to avoid overlinking linking with a unit uses the unit table as the link key which fails to detect overlinking for conversions like the following each links mile twice convert1impgalmiusgalmilkon convert1lkmimpgalmi usgalmilkon linkkey linkkey or link use key if given the key but not the link may be known when need to cancel a link record if not link or link or linkedpageslinkkey then return id end linkedpageslinkkey true following only works for language en but it should be safe on other wikis and overhead of doing it generally does not seem worthwhile local l linksub1 1lower linksub2 if link id or l id then return id elseif link s id or l s id then return idsub1 2 s else return link id end end local function variablenameclean unittable for sl wiki slovenian wikipedia a unit name depends on the value parameter clean is the unsigned rounded value in en digits as a string value source example for m integer 1 name1 meter also is the name of the unit integer 2 var1 metra integer 3 and 4 var2 metri integer else var3 metrov 0 and 5 or more realfraction var4 metra vari means the ith field in unittable varname if it exists and has an ith field otherwise name2 fields are separated with and are not empty a field for a unit using an si prefix has the prefix name inserted replacing if found or before the field otherwise local vname if clean 1 then vname unittable name1 elseif unittable varname then local i if clean 2 then i 1 elseif clean 3 or clean 4 then i 2 elseif cleanfind 1 true then i 4 else i 3 end vname splitunittable varname i end if vname then local siname rawgetunittable siname or local pos vnamefind 1 true if pos then vname vnamesub1 pos 1 siname vnamesubpos 1 else vname siname vname end return vname end return unittable name2 end local function linkedidunittable keyid wantlink clean return final unit id symbol or name optionally with a wikilink and update unittable sep if required keyid is one of symbol symus name1 name1us name2 name2us local abbron keyid symbol or keyid symus if abbron and wantlink then local symlink rawgetunittable symlink if symlink then return symlink for exceptions that have the linked symbol builtin end end local multiplier rawgetunittable multiplier local unittable if then local unit1 per1 top unittable or nil local unit2 per2 bottom unittable if abbron then if not unit1 then unittable sep no separator in 2acre end if not wantlink then local symbol unittable symbolraw if symbol then return symbol for exceptions that have the symbol builtin end end end local keyid2 unit2 is always singular if keyid name2 then keyid2 name1 elseif keyid name2us then keyid2 name1us else keyid2 keyid end local result if abbron then result elseif unit1 then result perword else result perword end if wantlink and unittable link then if abbron or not varname then result unit1 and unit1keyid or result unit2keyid2 else result unit1 and variablenameclean unit1 or result variablename1 unit2 end return makelinkunittable link result unittable end if unit1 then result linkedidunit1 keyid wantlink clean result end return result linkedidunit2 keyid2 wantlink 1 end if multiplier then a multiplier like 100 in 100km forces the unit to be plural multiplier fromenmultiplier if abbron then multiplier multiplier nbsp else multiplier multiplier if keyid name1 then keyid name2 elseif keyid name1us then keyid name2us end end else multiplier end local id unittable fixedname or varname and not abbron and variablenameclean unittable or unittablekeyid if wantlink then local link linkexceptionsunittable linkey or unittable symbol or unittable link if link then local before local i unittable customary if i 1 and unittable spus then i 2 show u s not us end if i 3 and abbron then i 4 abbreviate imperial to imp end local customary textcode customaryunitsi if customary then later this works for language en only but its esoteric so ignore for now local pertext if idsub1 1 then want unit usgal to display as u s gal not u s gal pertext id idsub2 elseif idsub1 4 then similarly want u s gallon not u s gallon but in practice this is unlikely to be used pertext id idsub5 else pertext end omit any usu s impimperial from start of id since that will be inserted local removes i 3 and usnbsp us u s nbsp u s or impnbsp imp imperial for prefix in ipairsremoves do local plen prefix if idsub1 plen prefix then id idsubplen 1 break end end before pertext makelinkcustomary link customary1 end id before makelinklink id unittable end end return multiplier id end local function makeidparms which unittable return id f where id unit name or symbol possibly modified f true if id is a name or false if id is a symbol using 1st or 2nd values which and for in or out unittable inout result is if no symbolname is to be used in addition set unittable sep or nbsp or the separator that caller will normally insert before the id if parms optvalues then unittable sep return end local inout unittable inout local info unittable valinfowhich local abbrorg parms abbrorg local adjectival parms optadjectival local disp parms disp local lk parms lk local wantlink lk on or lk inout local usename unittable usename local singular info singular if usename then old template does something like this if wantlink then a linked unit uses the standard singular else set nonstandard singular local flipped parms optflip if inout in then if not adjectival and abbrorg out or flipped then local value info value singular 0 value and value 1 0001 end else if abbrorg on or not flipped and abbrorg nil or abbrorg out or flipped and abbrorg in then singular info absvalue 1 0001 and not info isscientific end end end end local wantname if usename then wantname true else if abbrorg nil then if disp br or disp or or disp slash then wantname true end if unittable usesymbol then wantname false end end if wantname nil then local abbr parms abbr if abbr on or abbr inout or abbr mos and inout out then wantname false else wantname true end end end local key if wantname then if lk nil and unittable builtin hand then wantlink true end if parms optusenbsp then unittable sep nbsp else unittable sep end if parms optsingular then local value if inout in then value info value else value info absvalue end if value then some unusual units do not always set value field value absvalue singular 0 value and value 1 0001 end end if unittable engscale or parms israngex then engscale so 1e3kg gives 1 thousand kilograms plural israngex so 0 5x0 9mi gives 0 5 by 0 9 miles plural singular false end key adjectival or singular and name1 or name2 if unittable spus then key key us end else if unittable builtin hand then if parms opthandhh then unittable symbol hh later might want i18n applied to this end end unittable sep nbsp key unittable spus and symus or symbol end return linkedidunittable key wantlink info clean wantname end local function decoratevalueparms unittable which if needed update unittable so values will be shown with extra information for consistency with the old template but different from fmtpower the style to display powers of 10 includes displaynone to allow some browsers to copy for example 10 as 103 rather than as 103 local info local engscale unittable engscale local prefix unittable vprefix if engscale or prefix then info unittable valinfowhich if info decorated then return do not redecorate if repeating convert end info decorated true end if engscale then local inout unittable inout local abbr parms abbr if abbr on or abbr inout then info show info show span stylemarginleft0 2emspan stylemarginleft0 1em fromen10 spanspans styledisplaynonessup fromentostringengscale exponent sup else local numberid local lk parms lk if lk on or lk inout then numberid makelinkengscale link engscale1 else numberid engscale1 end wpnumeral recommends nbsp in values like 12 million info show info show parms optadjectival and or nbsp numberid end end if prefix then info show prefix info show end end local function processinputparms incurrent processing required once conversion return block of text to represent input valueunit if parms optoutputonly or parms optoutputnumberonly or parms optoutputunitonly then parms joins return end local firstunit local composite incurrent composite nil or table of units if composite then firstunit composite1 else firstunit incurrent end local id1 wantname makeidparms 1 firstunit local sep firstunit sep separator between value and unit set by makeid local preunit parms preunit1 if preunit then sep any separator is included in preunit else preunit end if parms optinputunitonly then parms joins if composite then local parts id1 for i unit in ipairscomposite do if i 1 then table insertparts makeidparms 1 unit end end id1 table concatparts end if wantname and parms optadjectival then return preunit hyphenatedid1 end return preunit id1 end local dispjoins textcode dispjoins local abbr parms abbr local disp parms disp if disp nil then special case for the most common setting parms joins dispjoinsb elseif disp x then old template does this if disp slash then if parms abbrorg nil then disp slashnbsp elseif abbr in or abbr out then disp slashsp else disp slashnosp end elseif disp sqbr then if abbr on then disp sqbrnbsp else disp sqbrsp end end parms joins dispjoinsdisp or dispjoinsb end if parms optalsosymbol and not composite then local join1 parms joins1 if join1 or join1 then parms joins join1 firstunitfirstunit spus and symus or symbol parms joins2 end end if incurrent builtin mach then local prefix id1 nbsp local range parms range local valinfo firstunit valinfo local result prefix valinfo1 show if range then for simplicity and because more not needed handle one range item only local prefix2 makeidparms 2 firstunit nbsp result rangetextrange1 wantname parms result prefix2 valinfo2 show end return preunit result end if composite then simplify assume there is no range and no decoration local mid local sep1 nbsp local sep2 if parms optadjectival then if not parms optflip then mid parms mid or end if wantname then sep1 sep2 end end local parts firstunit valinfo1 show sep1 id1 for i unit in ipairscomposite do if i 1 then table insertparts unit valinfo1 show sep1 makeidparms 1 unit end end return table concatparts sep2 mid end local result mos local range parms range if range then mos abbr mos if not mos or parms israngex and not wantname then linkedpagesfirstunit nil so the second and only id will be linked if wanted end end local id range nil and id1 or makeidparms 2 firstunit local extra washyphenated hyphenatedmaybeparms wantname sep id in if mos and washyphenated then mos false suppress repeat of unit in a range if linkedpagesfirstunit then linkedpagesfirstunit nil id makeidparms 2 firstunit extra hyphenatedmaybeparms wantname sep id in end end local valinfo firstunit valinfo if range then if range n 1 then like convert1x2ft one range item two values do what old template did local sep1 firstunit sep if mos then decoratevalueparms incurrent 1 decoratevalueparms incurrent 2 result valinfo1 show sep1 id1 elseif parms israngex and not wantname then if abbr in or abbr on then decoratevalueparms incurrent 1 end decoratevalueparms incurrent 2 result valinfo1 show sep1 id1 else if abbr in or abbr on then decoratevalueparms incurrent 1 end decoratevalueparms incurrent 2 result valinfo1 show end result rangetextrange1 wantname parms result valinfo2 show else like convert1x2x3ft two or more range items simplify decoratevalueparms incurrent 1 result valinfo1 show for i 1 range n do decoratevalueparms incurrent i1 result rangetextrangei wantname parms result valinfoi1 show end end else decoratevalueparms firstunit 1 result valinfo1 show end return result preunit extra end local function processoneoutputparms outcurrent processing required for each output unit return block of text to represent output valueunit local id1 wantname makeidparms 1 outcurrent local sep outcurrent sep set by makeid local preunit parms preunit2 if preunit then sep any separator is included in preunit else preunit end if parms optoutputunitonly then if wantname and parms optadjectival then return preunit hyphenatedid1 end return preunit id1 end if outcurrent builtin mach then local prefix id1 nbsp local range parms range local valinfo outcurrent valinfo local result prefix valinfo1 show if range then for simplicity and because more not needed handle one range item only result rangetextrange1 wantname parms result prefix valinfo2 show end return preunit result end local result local range parms range if range then if not parms israngex and not wantname then linkedpagesoutcurrent nil so the second and only id will be linked if wanted end end local id range nil and id1 or makeidparms 2 outcurrent local extra hyphenatedmaybeparms wantname sep id out local valinfo outcurrent valinfo if range then if range n 1 then local sep1 outcurrent sep local abbr parms abbr if parms israngex and not wantname then if abbr out or abbr on then decoratevalueparms outcurrent 1 end decoratevalueparms outcurrent 2 result valinfo1 show sep1 id1 else if abbr out or abbr on then decoratevalueparms outcurrent 1 end decoratevalueparms outcurrent 2 result valinfo1 show end result rangetextrange1 wantname parms result valinfo2 show else like convert1x2x3ft two or more range items simplify decoratevalueparms outcurrent 1 result valinfo1 show for i 1 range n do decoratevalueparms outcurrent i1 result rangetextrangei wantname parms result valinfoi1 show end end else decoratevalueparms outcurrent 1 result valinfo1 show end if parms optoutputnumberonly then return result end return result preunit extra end local function makeoutputsingleparms inunittable outunittable return true item where item wikitext of the conversion result for a single output which is not a combination or a multiple or return false t where t is an error message table outunittable valinfo collection local range parms range for i 1 range and range n 1 or 1 do local success info cvtroundparms inunittable valinfoi inunittable outunittable if not success then return false info end outunittable valinfoaddinfo end return true processoneoutputparms outunittable end local function makeoutputmultipleparms inunittable outunittable return true item where item wikitext of the conversion result for an output which is a multiple like ftin or return false t where t is an error message table local multiple outunittable multiple table of scaling factors will not be nil local combos outunittable combination table of unit tables will not be nil local abbr parms abbr local abbrorg parms abbrorg local disp parms disp local wantname abbrorg nil and disp or or disp slash or not abbr on or abbr out or abbr mos local wantlink parms lk on or parms lk out local mid local sep1 nbsp local sep2 if parms optadjectival then if parms optflip then mid parms mid or end if wantname then sep1 sep2 end end local dospell parms optspellout parms optspellout nil so the call to cvtround does not spell the value local function makeresultinfo isfirst local fmt outvalue sign local results for i 1 combos do local tfrac thisvalue strforce local outcurrent combosi outcurrent inout out local scale multiplei if i 1 then least significant unit in from ftin local decimals outcurrent frac outunittable frac local success outinfo cvtroundparms info inunittable outcurrent if not success then return false outinfo end if isfirst then outunittable valinfo outinfo in case output value of first least significant unit is needed end sign outinfo sign tfrac outinfo fractiontable if outinfo isscientific then strforce outinfo show decimals elseif tfrac then decimals else decimals outinfo showmatch numdot or outinfo show is in local language end fmt ulendecimals f to reproduce precision if decimals then if tfrac then outvalue flooroutinfo rawabsvalue integer part only fraction added later else outvalue flooroutinfo rawabsvalue 0 5 keep all integer digits of least significant unit end else outvalue outinfo absvalue end end if scale then outvalue thisvalue divideoutvalue scale else thisvalue outvalue end local id if wantname then if varname then local clean if strforce or tfrac then clean 1 dummy value to force name for floating point else clean formatfmt thisvalue end id variablenameclean outcurrent else id outcurrentthisvalue 1 and name1 or name2 end else id outcurrentsymbol end if wantlink then local link outcurrent link if link then id makelinklink id outcurrent end end local strval local inout i combos or outvalue 0 and out or trick so the last value processed first displayed has uppercase if requested if strforce and outvalue 0 then sign any sign is in strforce strval strforce show small values in scientific notation will only use least significant unit elseif tfrac then local wholestr thisvalue 0 and tostringthisvalue or nil strval formatfractionparms inout false wholestr tfrac numstr tfrac denstr dospell else strval thisvalue 0 and fromen0 or withseparatorparms formatfmt thisvalue if dospell then strval spellnumberparms inout strval or strval end end table insertresults strval sep1 id if outvalue 0 then break end fmt 0f only least significant unit can have a nonintegral value end local reversed count results for i 1 count do reversedi resultscount 1 i end return true sign table concatreversed sep2 end local valinfo inunittable valinfo local success result makeresultvalinfo1 true if not success then return false result end local range parms range if range then for i 1 range n do local success result2 makeresultvalinfoi1 if not success then return false result2 end result rangetextrangei wantname parms result result2 end end return true result mid end local function processparms inunittable outunittable return true s where s final wikitext result or return false t where t is an error message table linkedpages local success badoutput outfirst local badinputmcode inunittable badmcode false if input unit is valid local invalue1 inunittable valinfo1 value local outunit parms outunit if outunit nil or outunit then if badinputmcode then badoutput else success outunit getdefaultinvalue1 inunittable parms outunit outunit if not success then badoutput outunit end end end if not badoutput and not outunittable then success outunittable lookupoutunit parms optspus anycombination if success then local mismatch checkmismatchinunittable outunittable if mismatch then badoutput mismatch end else badoutput outunittable end end local flipped parms optflip and not badinputmcode local parts for part 1 2 do the lhs parts1 is normally the input but is the output if flipped process lhs first so it will be linked if wanted linking to the same item is suppressed in the rhs to avoid overlinking if part 1 and not flipped or part 2 and flipped then partspart processinputparms inunittable elseif badoutput then if badoutput then partspart messagebadoutput end else local outputs local combos nil for ft or ftin or table of unit tables for m ft if not outunittable multiple then nilfalse ft or m ft or table of factors ftin combos outunittable combination end local frac parms frac nil or denominator of fraction for output values if frac then apply fraction to the unit if only one or to nonsi units if a combination except that if a precision is also specified the fraction only applies to the hand unit that allows the following result convert156cmin hand1frac2 156 centimetres 61 4 in 15 1 hands however the following is handled elsewhere as a special case convert156cmhand in1frac2 156 centimetres 15 1 hands 61 in if combos then local precision parms precision for unit in ipairscombos do if unit builtin hand or not precision and not unit prefixes then unit frac frac end end else outunittable frac frac end end local imax combos and combos or 1 1 single unit or number of unit tables for i 1 imax do local success item local outcurrent combos and combosi or outunittable outcurrent inout out if i 1 then outfirst outcurrent if imax 1 and outcurrent builtin hand then outcurrent outnext combos2 builtin hand can influence next unit in a combination end end if outcurrent multiple then success item makeoutputmultipleparms inunittable outcurrent else success item makeoutputsingleparms inunittable outcurrent end if not success then return false item end table insertoutputs item end local sep parms tablejoins and parms tablejoins2 or partspart parms optinputunitonly and or table concatoutputs sep end end if parms optsortablein or parms optsortableout then local value if parms optsortablein then value invalue1 else local info outfirst and outfirst valinfo if info then info info1 value info rawabsvalue if value and info sign minus then value value end end end parts1 ntshvalue or 0 parms optsortabledebug parts1 end local wikitext if badinputmcode then wikitext parts1 messagebadinputmcode elseif parms tablejoins then wikitext parms tablejoins1 parts1 parms tablejoins2 parts2 else wikitext parts1 parms joins1 parts2 parms joins2 end if parms warnings and not badinputmcode then wikitext wikitext parms warnings end return true wikitext outunittable end local function mainconvertframe do convert and if needed do it again with higher default precision setconfigframe local result outunittable local success parms inunittable getparmsframegetparent if success then for i 1 2 do use counter so cannot get stuck repeating convert success result outunittable processparms inunittable outunittable if success and parms doconvertagain then parms doconvertagain false else break end end else result parms end if success then return result end return messageresult end return convert mainconvert 